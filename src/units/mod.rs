//! Units of Nano, i.e.
//! [Raw],
//! [Mnano] (10<sup>30</sup>),
//! [Nano] (10<sup>24</sup>).
//!
//! See https://docs.nano.org/protocol-design/distribution-and-units/#unit-dividers for the unit
//! dividers documentation.
//!
//! ## Example
//! ```
//! use feeless::units::{Nano, Mnano};
//! use std::convert::TryFrom;
//! use std::str::FromStr;
//!
//! # fn main() -> anyhow::Result<()> {
//! // One Mnano/NANO/Nano.
//! let mnano = Mnano::new(1);
//!
//! // Works with basic arithmetic.
//! let mnano = (mnano - Mnano::new(20)) / Mnano::new(2);
//!
//! // Can parse fractional strings.
//! assert_eq!(mnano, Mnano::from_str("-9.5")?);
//!
//! // Convert to nano.
//! let nano = mnano.to_nano();
//! assert_eq!(nano, Nano::from_str("-9500000")?);
//!
//! // Raw is a bounded type that does not allow values outside of u128, so this will fail because
//! // nano is currently negative.
//! assert!(nano.to_raw().is_err());
//!
//! let raw = Mnano::new(1).to_raw()?;
//! assert_eq!(raw.to_hex_string(), "0000000C9F2C9CD04674EDEA40000000");
//! assert_eq!(raw.to_u128(), 1_000_000_000_000_000_000_000_000_000_000u128);
//!
//! # Ok(())
//! # }
//! ```
//!
//! # Raw differences
//! [Raw] acts differently than the other units in this module, as its internal type is [u128].
//! This means it can not be a value outside of that, i.e. negative numbers or bigger than
//! [u128::MAX]. To get around this, use [UnboundedRaw], which internally uses [BigDecimal].
//!
//! [Nano], [Mnano] and [UnboundedRaw] all use [BigDecimal] internally. These all act
//! in a similar way with conversions between themselves. See the example below.
//!
//! ## Example
//! ```
//! use feeless::units::Nano;
//!
//! let nano = Nano::new(1).to_mnano().to_unbounded_raw().to_mnano().to_nano();
//! assert_eq!(nano, Nano::new(1));
//! ```
//!
//! # Working with floats (f32, f64)
//! The general recommendation is to never use floats when dealing with money due to inaccuracies
//! with floating point precision. You can however do it with [BigDecimal]â€”see the example below.
//!
//! Ideally if your API doesn't support [BigDecimal], it might be better to convert between
//! [String] and [BigDecimal] to make sure there are no rounding or floating point inaccuracies.
//!
//! ## Example
//! ```
//! use feeless::units::Mnano;
//! use bigdecimal::{BigDecimal, FromPrimitive};
//! use std::str::FromStr;
//!
//! # fn main() -> anyhow::Result<()> {
//! // If you really need to load from a float, use BigDecimal.
//! let big = BigDecimal::from_f64(1231239999999999.1).unwrap();
//! let mnano = Mnano::new(big);
//!
//! // Convert to float.
//! assert_eq!(mnano.to_f64(), 1231239999999999.1);
//!
//! // Better
//! let big = BigDecimal::from_str("9999999999.1").unwrap();
//! let mnano = Mnano::new(big);
//! assert_eq!(mnano.to_string(), "9999999999.1");
//!
//! # Ok(())
//! # }
//! ```
pub(crate) mod raw;

use crate::Error;
use bigdecimal::BigDecimal;
use bigdecimal::ToPrimitive;
use doc_comment::doc_comment;
use once_cell::sync::Lazy;
pub use raw::Raw;
use std::convert::TryFrom;
use std::str::FromStr;

/// This macro creates a struct to handle a specific denomination with arithmetic and conversions
/// to/from [Raw].
macro_rules! unit {
    ($struct_name:ident, $multiplier:expr) => {
        doc_comment! {
        concat!("The ", stringify!($struct_name), " (10<sup>", stringify!($multiplier) ,"</sup> raw) unit denomination.
        
See the [module documentation](crate::units) for more information as this is generated by a macro and it's tricky to write docs for it :).
        "),
        #[derive(Debug, Clone, Eq, PartialEq)]
        pub struct $struct_name(BigDecimal);
        }

        impl $struct_name {
            fn lazy_multiplier() -> Lazy<BigDecimal> {
                let multiplier: Lazy<BigDecimal> = Lazy::new(|| {
                    let value = 10u128.pow($multiplier);
                    // For some reason from_u128 fails with `None`.
                    BigDecimal::from_str(value.to_string().as_str()).unwrap()
                });
                multiplier
            }

            pub fn new<T: Into<BigDecimal>>(v: T) -> Self {
                Self(v.into())
            }

            /// When initializing, use a raw value intsead of this unit type.
            /// ```
            /// # use feeless::units::Mnano;
            /// # use bigdecimal::BigDecimal;
            /// # use std::str::FromStr;
            /// # fn main() -> anyhow::Result<()> {
            /// let decimal = BigDecimal::from_str("1_000_000_000_000_000_000_000_000_000_000")?;
            /// let mnano = Mnano::new_with_raw(decimal);
            /// assert_eq!(mnano, Mnano::new(1));
            /// # Ok(())
            /// # }
            /// ```
            pub fn new_with_raw<T: Into<BigDecimal>>(v: T) -> Self {
                Self(v.into() / &*Self::lazy_multiplier())
            }

            /// Returns a [Raw].
            ///
            /// If the converted amount is out of range of `0..u128::MAX` it will return an error.
            /// ```
            /// # use feeless::units::Mnano;
            /// # use bigdecimal::BigDecimal;
            /// # use std::str::FromStr;
            /// # use bigdecimal::FromPrimitive;
            /// # use feeless::Raw;
            /// # fn main() -> anyhow::Result<()> {
            /// let mnano = Mnano::new(BigDecimal::from_str("0.000000000000000000000000000001")?);
            /// let raw = mnano.to_raw()?;
            /// assert_eq!(raw, Raw::new(1u128));
            /// # Ok(())
            /// # }
            /// ```
            pub fn to_raw(&self) -> Result<Raw, Error> {
                Raw::try_from(&self.to_raw_big_decimal())
            }

            pub fn to_unbounded_raw(&self) -> UnboundedRaw {
                UnboundedRaw::new(self.to_raw_big_decimal())
            }

            pub fn to_mnano(&self) -> Mnano {
                Mnano::new_with_raw(self.to_raw_big_decimal())
            }

            pub fn to_nano(&self) -> Nano {
                Nano::new_with_raw(self.to_raw_big_decimal())
            }

            pub fn to_f64(&self) -> f64 {
                // TODO: unwrap ok here?
                self.0.to_f64().unwrap()
            }

            /// Returns a [BigDecimal] with the value of this type.
            /// ```
            /// # use feeless::units::Nano;
            /// # use bigdecimal::BigDecimal;
            /// # use std::str::FromStr;
            /// # use bigdecimal::FromPrimitive;
            /// # fn main() -> anyhow::Result<()> {
            /// let nano = Nano::new(1);
            /// let decimal = nano.to_big_decimal();
            /// assert_eq!(decimal, &BigDecimal::from_str("1")?);
            /// # Ok(())
            /// # }
            /// ```
            pub fn to_big_decimal(&self) -> &BigDecimal {
                &self.0
            }

            /// Returns a [BigDecimal] with the raw value.
            /// ```
            /// # use feeless::units::Nano;
            /// # use bigdecimal::BigDecimal;
            /// # use std::str::FromStr;
            /// # fn main() -> anyhow::Result<()> {
            /// let nano = Nano::new(1);
            /// let decimal = nano.to_raw_big_decimal();
            /// assert_eq!(decimal, BigDecimal::from_str("1000000000000000000000000")?);
            /// # Ok(())
            /// # }
            /// ```
            pub fn to_raw_big_decimal(&self) -> BigDecimal {
                &self.0 * &*Self::lazy_multiplier()
            }
        }

        impl ToString for $struct_name {
            fn to_string(&self) -> String {
                self.0.to_string()
            }
        }

        impl FromStr for $struct_name {
            type Err = Error;

            fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                Ok(Self::new(BigDecimal::from_str(s)?))
            }
        }

        impl From<Raw> for $struct_name {
            fn from(raw: Raw) -> Self {
                // TODO: unwrap ok here?
                // TODO: from_u128 returns None for some reason...
                let big_dec = BigDecimal::from_str(raw.0.to_string().as_str()).unwrap();
                Self(big_dec / &*Self::lazy_multiplier())
            }
        }

        impl From<&Raw> for $struct_name {
            fn from(raw: &Raw) -> Self {
                Self::from(raw.clone())
            }
        }

        impl std::ops::Add for $struct_name {
            type Output = Self;

            fn add(self, rhs: Self) -> Self::Output {
                Self::new(self.0 + rhs.0)
            }
        }

        impl std::ops::Sub for $struct_name {
            type Output = Self;

            fn sub(self, rhs: Self) -> Self::Output {
                Self::new(self.0 - rhs.0)
            }
        }

        impl std::ops::Div for $struct_name {
            type Output = Self;

            fn div(self, rhs: Self) -> Self::Output {
                Self::new(self.0 / rhs.0)
            }
        }

        impl std::ops::Mul for $struct_name {
            type Output = Self;

            fn mul(self, rhs: Self) -> Self::Output {
                Self::new(self.0 * rhs.0)
            }
        }

        impl std::ops::AddAssign for $struct_name {
            fn add_assign(&mut self, rhs: Self) {
                self.0 += rhs.0;
            }
        }

        impl std::ops::SubAssign for $struct_name {
            fn sub_assign(&mut self, rhs: Self) {
                self.0 -= rhs.0;
            }
        }

        impl std::ops::MulAssign for $struct_name {
            fn mul_assign(&mut self, rhs: Self) {
                self.0 *= rhs.0;
            }
        }

        // TODO: binary assignment operation `/=` cannot be applied to type `bigdecimal::BigDecimal`
        // impl std::ops::DivAssign for $struct_name {
        //     fn div_assign(&mut self, rhs: Self) {
        //         self.0 /= rhs.0;
        //     }
        // }
    };
}

unit!(Mnano, 30);
unit!(Nano, 24);
unit!(UnboundedRaw, 0);

#[cfg(test)]
mod tests {
    use super::*;
    use bigdecimal::FromPrimitive;

    #[test]
    fn conversions() {
        let raw = Raw::new(1u128).to_nano().to_mnano().to_raw().unwrap();
        assert_eq!(raw, Raw::new(1u128));

        let nano = Nano::new(1)
            .to_nano()
            .to_nano()
            .to_nano()
            .to_nano() // Yes you can convert from nano to nano. Generated by the macro!
            .to_mnano()
            .to_nano();
        assert_eq!(nano, Nano::new(1));
    }

    #[test]
    fn negative() {
        assert!(Mnano::new(-1).to_raw().is_err());
    }

    #[test]
    fn mnano_overflow() {
        assert!(Mnano::new(340282366u64).to_raw().is_ok());
        assert!(Mnano::new(340282367u64).to_raw().is_err());

        Mnano::new(BigDecimal::from_str("340282366.920938463463374607431768211455").unwrap())
            .to_raw()
            .unwrap();
        // Just one raw over the max.
        assert!(Mnano::new(
            BigDecimal::from_str("340282366.920938463463374607431768211456").unwrap()
        )
        .to_raw()
        .is_err());
    }

    #[test]
    fn nano_overflow() {
        let d = BigDecimal::from_str("340282366920938.463463374607431768211455").unwrap();
        Nano::new(d).to_raw().unwrap();

        // One over the max
        let d = BigDecimal::from_str("340282366920938.463463374607431768211456").unwrap();
        assert!(Nano::new(d).to_raw().is_err());
    }

    #[test]
    fn is_something_wrong_with_big_decimal_u128() {
        assert_eq!(
            u64::MAX.to_string(),
            BigDecimal::from_u64(u64::MAX).unwrap().to_string()
        );
        // TODO: This doesn't work
        // assert_eq!(
        //     u128::MAX.to_string(),
        //     BigDecimal::from_u128(u128::MAX).unwrap().to_string()
        // );
    }

    #[test]
    fn arithmetic() {
        assert_eq!(Nano::new(1) + Nano::new(-2), Nano::new(-1));
        assert_eq!(Nano::new(2) - Nano::new(1), Nano::new(1));
        assert_eq!(Nano::new(10) / Nano::new(2), Nano::new(5));
        assert_eq!(Nano::new(10) * Nano::new(2), Nano::new(20));

        let mut n = Nano::new(1);
        n += Nano::new(2);
        assert_eq!(n, Nano::new(3));
        n -= Nano::new(1);
        assert_eq!(n, Nano::new(2));
        n *= Nano::new(4);
        assert_eq!(n, Nano::new(8));
    }
}
